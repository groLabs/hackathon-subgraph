# Enums

enum TxType {
  core_deposit
  core_withdrawal
  staker_deposit
  staker_withdrawal
  transfer_in
  transfer_out
  claim
  multiclaim
  vest
  approval
}

enum Status {
  ok
  error
}

enum NetworkName {
  mainnet
  avalanche
}

# Entities

type User @entity {
  id: ID! # userAddress
  collectivesOwner: [Collective!] @derivedFrom(field: "ownerAddress")
  collectivesParticipant: [CollectiveParticipant!] @derivedFrom(field: "participantAddress")
}

type Collective @entity {
  id: ID! # collectiveAddress
  ownerAddress: User! # FK to User on collectivesOwner[]
  participants: [Bytes!]!
  description: String!
  creation_date: Int!
  cliff: Int!
  vesting_time: Int!
}

type CollectiveParticipant @entity {
  id: ID! # collectiveAddress-participantAddress
  name: String!
  collectiveAddress: Collective!  # FK to Collective on participants[]
  participantAddress: User! # FK to User on collectivesParticipant[]
  tokenAddress: Bytes!
  amount: BigDecimal!
  price: BigDecimal!
  stakedAmount: BigDecimal!
  unstakedAmount: BigDecimal!
}

type CollectiveParticipantClaim @entity {
  id: ID! # collectiveAddress-participantAddress-tokenAddress
  collectiveParticipant: CollectiveParticipant!
  claimAmount: BigDecimal!
}


# LogNewCollectiveInitialized(string[] name, address[], tokens, uint128[] price, address[] users, uint256[] amounts, uint32 collectiveInfo.cliff, uint32 collectiveInfo.vestimTime);
# LogNewAdmin(address newAdmin);
# LogNewPoolInitialized(uint256);
# LogTokensStaked(address user, uint256 amount);
# LogTokensUnstaked(address user, uint256 unstakedAmount, address[] tokens, uint256[] claim)
# LogTokensClaimed(address user, address[] tokens, uint256[] claim)

# testing
type GRouterTx @entity {
  id: ID!
  sender: Bytes!
  amount: BigDecimal!
  type: TxType
}